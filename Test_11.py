#!/usr/bin/Python3
#encoding="utf-8"


print("======================== 正则表达式 ========================")

"""
精确匹配: 正则表达式中，直接给出字符。
	\d 匹配一个数字
		"00\d"    可以匹配到 
			eg: 007   001

		"\d\d\d"  匹配三个数字  
			eg: 123   321


	\w 匹配一个数字 或者 字母
		"00\w"   可以匹配到 007 也可以匹配到 
			eg: 00a   00d

		"\w\w\w" 匹配三个数字或者字母
			eg: wea   erv


	. 可以匹配任意字符
		"py." 匹配 py后跟一个任意字符
			eg: pya   py!   py?


	\s 可以匹配一个空格
		"\d\s\d" 匹配两个数字中间有一个空格
			eg: "1 2"


	[] 表示范围
		[0-9a-zA-Z\_]   可以匹配一个数字、字母或者下划线；
	    [0-9a-zA-Z\_]+  可以匹配至少由一个数字、字母或者下划线组成的字符串，
	    	eg: a100    0_Z   Py3000

	    [a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或下划线开头，后接任意个
	                             由一个数字、字母或者下划线组成的字符串，
	                             也就是Python合法的变量；

	    [a-zA-Z\_][0-9a-zA-Z\_]{0, 19}  更精确地限制了变量的长度是1-20个字符
	                                   （前面1个字符+后面最多19个字符）。

        A|B  可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'。
        ^表示行的开头，^\d表示必须以数字开头。
		$表示行的结束，\d$表示必须以数字结束。

不定长匹配: 匹配的字符长度不定
	*     表示人一个字符       >= 0
	+     表示至少一个字符     >= 1
	?     表示一个或者零个      =0 | =1
	{n}   表示 n个字符        =n
		"\d{3}" 匹配三个数字
			eg: 123

	{n,m} 表示 n~m个字符      n<= x <=m
		"\w{1,3}" 匹配一到三个数字或者字母
			eg: s  se 12s

		"\d{3}\-\d{8}"
		   eg: 021-68333168

"""




"""
	re模块
		有了准备知识，我们就可以在Python中使用正则表达式了。Python提供re模块，
	包含所有正则表达式的功能。由于Python的字符串本身也用\转义，所以要特别注意：
"""
s = "ABC\\-001"  # 转义之后 "ABC\-001"

# 前面有 r 的话就不用考虑转义的情况
s = r"ABC\-001"  # ABC\-001

print("=== 正则表达式 === 转义：",s)

import re

# match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。

# <_sre.SRE_Match object; span=(0, 12), match='021-68888888'>
reValue = re.match(r"^\d{3}-\d{8}$", "021-68888888")
print("=== 正则表达式 === 匹配：",reValue) 

if re.match(r"13\d{9}", "13611888888"):
	print("是电话号码！")
else:
	print("不是电话号码！")



"""
	切分字符串
	用正则表达式切分字符串比用固定的字符更灵活。
"""

# 自带的切割无法识别连续空格
list_ = "A B C   D".split(" ")  # ['A', 'B', 'C', '', '', 'D']

# 使用正则表达式
# \s 匹配一个空格 \s+ 匹配至少一个空格
list_ = re.split(r"\s+", "A B C   D") # ['A', 'B', 'C', 'D']

list_ = re.split(r"[\s\,]+", "a, b,, c   D") # ['a', 'b', 'c', 'D']
print("=== 正则表达式 === 切分字符：",list_)




"""
	分组
	除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要
提取的分组（Group）。
	^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和
本地号码
"""

reValue = re.match(r"^(\d{3})-(\d{8})$", "021-68888888")
# 021-68888888
group_01 = reValue.group(0)
# 021
group_02 = reValue.group(1)
# 68888888
group_03 = reValue.group(2)

 

"""
	贪婪匹配
	最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。
举例如下，匹配出数字后面的0：
"""
reValue = re.match(r"^(\d+)(0*)$", "52100131400")
# 52100131400
group_01 = reValue.group(0)
# 52100131400
group_02 = reValue.group(1)
# 
group_03 = reValue.group(2)

# 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。

# 加个？把他变为非贪婪模式，后面的 0 就可以匹配到了
reValue = re.match(r"^(\d+?)(0*)$", "52100131400")
# 52100131400
group_01 = reValue.group(0)
# 521001314
group_02 = reValue.group(1)
# 00
group_03 = reValue.group(2)
print("=== 正则表达式 === group_01:%s group_02:%s group_03:%s"
						%(group_01, group_02, group_03))





"""
	编译

	当我们在Python中使用正则表达式时，re模块内部会干两件事情：

	编译正则表达式，如果正则表达式的字符串本身不合法，会报错；

	用编译后的正则表达式去匹配字符串。

	如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，
接下来重复使用时就不需要编译这个步骤了，直接匹配：

"""

# 编译
re_tel = re.compile(r"^(\d{3})-(\d{3,8})$")

# 使用
reValue = re_tel.match("021-123").groups()     # ('021', '123')
reValue = re_tel.match("021-489980").groups()  # ('021', '489980')

print("=== 正则表达式 === 编译：",reValue)


"""
	编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，
所以调用对应的方法时不用给出正则字符串。
"""


